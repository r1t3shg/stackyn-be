// Package apps provides data models and database operations for applications.
// An "app" represents a deployable application with a Git repository.
package apps

import (
	"database/sql"
	"time"
)

// App represents a deployable application in the system.
// Each app has a unique name and a Git repository URL that will be deployed.
type App struct {
	// ID is the unique identifier for the app (auto-generated by database)
	ID int `json:"id"`

	// Name is the unique name of the application (e.g., "my-web-app")
	Name string `json:"name"`

	// RepoURL is the Git repository URL that will be cloned and deployed
	// (e.g., "https://github.com/user/repo.git")
	RepoURL string `json:"repo_url"`

	// CreatedAt is the timestamp when the app was first created
	CreatedAt time.Time `json:"created_at"`

	// UpdatedAt is the timestamp when the app was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// Store provides database operations for the App model.
// It encapsulates all SQL queries related to apps.
type Store struct {
	// db is the database connection used for all queries
	db *sql.DB
}

// NewStore creates a new Store instance with the provided database connection.
//
// Parameters:
//   - db: A database connection (typically from db.New())
//
// Returns:
//   - *Store: A new Store instance ready to perform app operations
func NewStore(db *sql.DB) *Store {
	return &Store{db: db}
}

// Create inserts a new app into the database and returns it with generated fields.
// The app name must be unique (enforced by database constraint).
//
// Parameters:
//   - name: The unique name for the application
//   - repoURL: The Git repository URL to deploy
//
// Returns:
//   - *App: The newly created app with ID and timestamps populated, or nil on error
//   - error: Database error if insertion fails (e.g., duplicate name, connection issue)
func (s *Store) Create(name, repoURL string) (*App, error) {
	var app App
	// Use RETURNING clause to get the generated ID and timestamps in one query
	err := s.db.QueryRow(
		"INSERT INTO apps (name, repo_url) VALUES ($1, $2) RETURNING id, name, repo_url, created_at, updated_at",
		name, repoURL,
	).Scan(&app.ID, &app.Name, &app.RepoURL, &app.CreatedAt, &app.UpdatedAt)
	if err != nil {
		return nil, err
	}
	return &app, nil
}

// GetByID retrieves an app by its unique ID.
//
// Parameters:
//   - id: The unique identifier of the app to retrieve
//
// Returns:
//   - *App: The app if found, or nil on error
//   - error: sql.ErrNoRows if app not found, or other database error
func (s *Store) GetByID(id int) (*App, error) {
	var app App
	err := s.db.QueryRow(
		"SELECT id, name, repo_url, created_at, updated_at FROM apps WHERE id = $1",
		id,
	).Scan(&app.ID, &app.Name, &app.RepoURL, &app.CreatedAt, &app.UpdatedAt)
	if err != nil {
		return nil, err
	}
	return &app, nil
}

// List retrieves all apps from the database, ordered by creation date (newest first).
//
// Returns:
//   - []*App: A slice of all apps in the database, or nil on error
//   - error: Database error if query fails
func (s *Store) List() ([]*App, error) {
	// Query all apps, ordered by creation date descending (newest first)
	rows, err := s.db.Query("SELECT id, name, repo_url, created_at, updated_at FROM apps ORDER BY created_at DESC")
	if err != nil {
		return nil, err
	}
	// Always close rows to free database resources
	defer rows.Close()

	var apps []*App
	// Iterate through each row
	for rows.Next() {
		var app App
		// Scan the row data into the app struct
		if err := rows.Scan(&app.ID, &app.Name, &app.RepoURL, &app.CreatedAt, &app.UpdatedAt); err != nil {
			return nil, err
		}
		// Append to the results slice
		apps = append(apps, &app)
	}
	// Check for errors during iteration
	return apps, rows.Err()
}

// Delete removes an app from the database by ID.
// Note: This will cascade delete all associated deployments (enforced by foreign key).
//
// Parameters:
//   - id: The unique identifier of the app to delete
//
// Returns:
//   - error: Database error if deletion fails
func (s *Store) Delete(id int) error {
	_, err := s.db.Exec("DELETE FROM apps WHERE id = $1", id)
	return err
}

