// Package deployments provides data models and database operations for deployments.
// A deployment represents a single deployment attempt of an app, tracking its progress
// from creation through building to running (or failure).
package deployments

import (
	"database/sql"
	"time"
)

// Status represents the current state of a deployment.
// Deployments progress through: pending -> building -> running (or failed)
type Status string

// Deployment status constants representing the lifecycle states.
const (
	// StatusPending indicates the deployment is queued and waiting to be processed
	StatusPending Status = "pending"

	// StatusBuilding indicates the deployment is currently being built (Git clone + Docker build)
	StatusBuilding Status = "building"

	// StatusRunning indicates the deployment is successfully running in a container
	StatusRunning Status = "running"

	// StatusFailed indicates the deployment encountered an error and cannot proceed
	StatusFailed Status = "failed"

	// StatusStopped indicates the deployment was manually stopped
	StatusStopped Status = "stopped"
)

// Deployment represents a single deployment instance of an app.
// It tracks the entire deployment lifecycle from creation to completion.
type Deployment struct {
	// ID is the unique identifier for this deployment (auto-generated by database)
	ID int `json:"id"`

	// AppID is the foreign key reference to the app being deployed
	AppID int `json:"app_id"`

	// Status is the current state of the deployment (pending, building, running, failed, stopped)
	Status Status `json:"status"`

	// ImageName is the Docker image name that was built for this deployment
	// Format: mvp-{app-name}:{deployment-id}
	// Empty until the Docker build completes successfully
	ImageName sql.NullString `json:"image_name,omitempty"`

	// ContainerID is the Docker container ID of the running container
	// Empty until the container is successfully started
	ContainerID sql.NullString `json:"container_id,omitempty"`

	// Subdomain is the subdomain assigned to this deployment
	// Format: {app-name}-{deployment-id}
	// The app will be accessible at {subdomain}.{baseDomain}
	Subdomain sql.NullString `json:"subdomain,omitempty"`

	// BuildLog contains the Docker build output/logs
	// This is captured during the Docker image build process
	BuildLog sql.NullString `json:"build_log,omitempty"`

	// ErrorMessage contains any error message if the deployment failed
	// Empty if deployment is successful or still in progress
	ErrorMessage sql.NullString `json:"error_message,omitempty"`

	// CreatedAt is the timestamp when the deployment was created
	CreatedAt time.Time `json:"created_at"`

	// UpdatedAt is the timestamp when the deployment was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// Store provides database operations for the Deployment model.
// It encapsulates all SQL queries related to deployments.
type Store struct {
	// db is the database connection used for all queries
	db *sql.DB
}

// NewStore creates a new Store instance with the provided database connection.
//
// Parameters:
//   - db: A database connection (typically from db.New())
//
// Returns:
//   - *Store: A new Store instance ready to perform deployment operations
func NewStore(db *sql.DB) *Store {
	return &Store{db: db}
}

// Create inserts a new deployment for the given app with status "pending".
// This is typically called when a new app is created or a redeployment is triggered.
//
// Parameters:
//   - appID: The ID of the app to deploy
//
// Returns:
//   - *Deployment: The newly created deployment with ID and timestamps populated, or nil on error
//   - error: Database error if insertion fails
func (s *Store) Create(appID int) (*Deployment, error) {
	var d Deployment
	// Create deployment with initial status of "pending"
	// Use RETURNING clause to get all fields in one query
	err := s.db.QueryRow(
		"INSERT INTO deployments (app_id, status) VALUES ($1, $2) RETURNING id, app_id, status, image_name, container_id, subdomain, build_log, error_message, created_at, updated_at",
		appID, StatusPending,
	).Scan(&d.ID, &d.AppID, &d.Status, &d.ImageName, &d.ContainerID, &d.Subdomain, &d.BuildLog, &d.ErrorMessage, &d.CreatedAt, &d.UpdatedAt)
	if err != nil {
		return nil, err
	}
	return &d, nil
}

// GetByID retrieves a deployment by its unique ID.
//
// Parameters:
//   - id: The unique identifier of the deployment to retrieve
//
// Returns:
//   - *Deployment: The deployment if found, or nil on error
//   - error: sql.ErrNoRows if deployment not found, or other database error
func (s *Store) GetByID(id int) (*Deployment, error) {
	var d Deployment
	err := s.db.QueryRow(
		"SELECT id, app_id, status, image_name, container_id, subdomain, build_log, error_message, created_at, updated_at FROM deployments WHERE id = $1",
		id,
	).Scan(&d.ID, &d.AppID, &d.Status, &d.ImageName, &d.ContainerID, &d.Subdomain, &d.BuildLog, &d.ErrorMessage, &d.CreatedAt, &d.UpdatedAt)
	if err != nil {
		return nil, err
	}
	return &d, nil
}

// GetPending retrieves all deployments with status "pending", ordered by creation time (oldest first).
// This is used by the deployment worker to find work items to process.
//
// Returns:
//   - []*Deployment: A slice of all pending deployments, or nil on error
//   - error: Database error if query fails
func (s *Store) GetPending() ([]*Deployment, error) {
	// Order by created_at ASC so oldest pending deployments are processed first (FIFO)
	rows, err := s.db.Query(
		"SELECT id, app_id, status, image_name, container_id, subdomain, build_log, error_message, created_at, updated_at FROM deployments WHERE status = $1 ORDER BY created_at ASC",
		StatusPending,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var deployments []*Deployment
	for rows.Next() {
		var d Deployment
		if err := rows.Scan(&d.ID, &d.AppID, &d.Status, &d.ImageName, &d.ContainerID, &d.Subdomain, &d.BuildLog, &d.ErrorMessage, &d.CreatedAt, &d.UpdatedAt); err != nil {
			return nil, err
		}
		deployments = append(deployments, &d)
	}
	return deployments, rows.Err()
}

// UpdateStatus updates the status of a deployment and refreshes the updated_at timestamp.
//
// Parameters:
//   - id: The deployment ID to update
//   - status: The new status value (pending, building, running, failed, stopped)
//
// Returns:
//   - error: Database error if update fails
func (s *Store) UpdateStatus(id int, status Status) error {
	_, err := s.db.Exec(
		"UPDATE deployments SET status = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2",
		status, id,
	)
	return err
}

// UpdateImage updates the Docker image name for a deployment.
// Called after a successful Docker build.
//
// Parameters:
//   - id: The deployment ID to update
//   - imageName: The Docker image name that was built (e.g., "mvp-myapp:123")
//
// Returns:
//   - error: Database error if update fails
func (s *Store) UpdateImage(id int, imageName string) error {
	_, err := s.db.Exec(
		"UPDATE deployments SET image_name = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2",
		imageName, id,
	)
	return err
}

// UpdateContainer updates the container ID and subdomain for a deployment.
// Called after a container is successfully started.
//
// Parameters:
//   - id: The deployment ID to update
//   - containerID: The Docker container ID
//   - subdomain: The subdomain assigned to this deployment
//
// Returns:
//   - error: Database error if update fails
func (s *Store) UpdateContainer(id int, containerID, subdomain string) error {
	_, err := s.db.Exec(
		"UPDATE deployments SET container_id = $1, subdomain = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $3",
		containerID, subdomain, id,
	)
	return err
}

// UpdateBuildLog updates the build log for a deployment.
// The build log contains the Docker build output.
//
// Parameters:
//   - id: The deployment ID to update
//   - log: The build log content (typically Docker build output)
//
// Returns:
//   - error: Database error if update fails
func (s *Store) UpdateBuildLog(id int, log string) error {
	_, err := s.db.Exec(
		"UPDATE deployments SET build_log = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2",
		log, id,
	)
	return err
}

// UpdateError updates the error message and sets status to "failed" for a deployment.
// This is called when a deployment encounters an error during processing.
//
// Parameters:
//   - id: The deployment ID to update
//   - errorMsg: The error message describing what went wrong
//
// Returns:
//   - error: Database error if update fails
func (s *Store) UpdateError(id int, errorMsg string) error {
	// Automatically set status to "failed" when recording an error
	_, err := s.db.Exec(
		"UPDATE deployments SET error_message = $1, status = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $3",
		errorMsg, StatusFailed, id,
	)
	return err
}

// ListByAppID retrieves all deployments for a specific app, ordered by creation time (newest first).
//
// Parameters:
//   - appID: The ID of the app whose deployments to retrieve
//
// Returns:
//   - []*Deployment: A slice of all deployments for the app, or nil on error
//   - error: Database error if query fails
func (s *Store) ListByAppID(appID int) ([]*Deployment, error) {
	// Order by created_at DESC so most recent deployments appear first
	rows, err := s.db.Query(
		"SELECT id, app_id, status, image_name, container_id, subdomain, build_log, error_message, created_at, updated_at FROM deployments WHERE app_id = $1 ORDER BY created_at DESC",
		appID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var deployments []*Deployment
	for rows.Next() {
		var d Deployment
		if err := rows.Scan(&d.ID, &d.AppID, &d.Status, &d.ImageName, &d.ContainerID, &d.Subdomain, &d.BuildLog, &d.ErrorMessage, &d.CreatedAt, &d.UpdatedAt); err != nil {
			return nil, err
		}
		deployments = append(deployments, &d)
	}
	return deployments, rows.Err()
}
